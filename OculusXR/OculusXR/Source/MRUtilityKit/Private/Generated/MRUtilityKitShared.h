// Copyright (c) Meta Platforms, Inc. and affiliates.

// @generated by `buck2 run //arvr/projects/mixedreality/libraries/mrutilitykit:build_and_deploy unreal`

#pragma once

#include <float.h>
#include <stddef.h>
#include <stdint.h>
#include "CoreTypes.h"
#include "Math/MathFwd.h"

struct MRUKShared
{
    static MRUKShared* GetInstance() { return Instance; }

    static void LoadMRUKSharedLibrary();
    static void FreeMRUKSharedLibrary();

    enum MrukResult
    {
        MRUK_SUCCESS,
        MRUK_ERROR_INVALID_ARGS,
    };

    struct MrukPolygon2f
    {
        const FVector2f* points;
        uint32_t numPoints;
    };

    struct MrukMesh2f
    {
        FVector2f* vertices;
        uint32_t numVertices;
        uint32_t* indices;
        uint32_t numIndices;
    };

    struct MrukMesh3f
    {
        FVector3f* vertices;
        uint32_t numVertices;
        uint32_t* indices;
        uint32_t numIndices;
    };


    /**
     * Add two vectors together. This is implemented as a test to ensure the native shared
     * library is working correctly.
     *
     * @param[in] a The first vector.
     * @param[in] b The second vector.
     * @return The sum of the two vectors.
     */
    FVector3f (*AddVectors)(FVector3f a, FVector3f b);

    /**
     * Triangulate a polygon with holes, any winding order works. The first polyline defines the main
     * polygon. Following polylines define holes. This function will allocate memory for the vertices
     * and indices. You *MUST* call FreeMesh() when you are done with it or you will leak memory.
     *
     * @param[in] polygons The polygon to triangulate.
     * @param[in] numPolygons The number of polygons in the array.
     * @return mesh The triangulated mesh.
     */
    MrukMesh2f (*TriangulatePolygon)(const MrukPolygon2f* polygons, uint32_t numPolygons);

    /**
     * Free the memory allocated by TriangulatePolygon.
     *
     * @param[in] mesh The mesh to free.
     */
    void (*FreeMesh)(MrukMesh2f* mesh);

    /**
     * Compute the mesh segmentation for a given set of vertices, indices and segmentation points.
     * You *MUST* call FreeMeshSegmentation() on the meshSegments array when you are done with it or you
     * will leak memory.
     *
     * @param[in] vertices The mesh vertices.
     * @param[in] numVertices The number of vertices in the mesh.
     * @param[in] indices The mesh indices.
     * @param[in] numIndices The number of indices in the mesh.
     * @param[in] segmentationPoints The points that should be used to calculate the segments.
     * @param[in] numSegmentationPoints The number of segmentation points.
     * @param[in] reservedMin The minimum bounding box for the reserved segment.
     * @param[in] reservedMax The maximum bounding box for the reserved segment.
     * @param[out] meshSegments The resulting segments.
     * @param[out] numSegments The number of segments in the resulting array.
     * @param[out] reservedSegment The segment that is inside the reserved bounding box.
     */
    MrukResult (*ComputeMeshSegmentation)(const FVector3f* vertices, uint32_t numVertices, const uint32_t* indices, uint32_t numIndices, const FVector3f* segmentationPoints, uint32_t numSegmentationPoints, FVector3f reservedMin, FVector3f reservedMax, MrukMesh3f** meshSegments, uint32_t* numSegments, MrukMesh3f* reservedSegment);

    /**
     * Free the memory allocated by ComputeMeshSegmentation.
     *
     * @param[in] meshSegments The array of segments to free.
     * @param[in] numSegments The number of segments in the array.
     * @param[in] reservedSegment The reserved segment to free.
     */
    void (*FreeMeshSegmentation)(const MrukMesh3f* meshSegments, uint32_t numSegments, MrukMesh3f* reservedSegment);

private:

    void LoadNativeFunctions()
    {
        AddVectors = reinterpret_cast<decltype(AddVectors)>(LoadFunction(TEXT("AddVectors")));
        TriangulatePolygon = reinterpret_cast<decltype(TriangulatePolygon)>(LoadFunction(TEXT("TriangulatePolygon")));
        FreeMesh = reinterpret_cast<decltype(FreeMesh)>(LoadFunction(TEXT("FreeMesh")));
        ComputeMeshSegmentation = reinterpret_cast<decltype(ComputeMeshSegmentation)>(LoadFunction(TEXT("ComputeMeshSegmentation")));
        FreeMeshSegmentation = reinterpret_cast<decltype(FreeMeshSegmentation)>(LoadFunction(TEXT("FreeMeshSegmentation")));
    }

    void UnloadNativeFunctions()
    {
        AddVectors = nullptr;
        TriangulatePolygon = nullptr;
        FreeMesh = nullptr;
        ComputeMeshSegmentation = nullptr;
        FreeMeshSegmentation = nullptr;
    }

    void* LoadFunction(const TCHAR* ProcName);

    static MRUKShared* Instance;
    void* MRUKSharedHandle;

    MRUKShared(void* handle);
    ~MRUKShared();
};
